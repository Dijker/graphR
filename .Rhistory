install.packages("shinydashboard")
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?icon
runApp()
runApp()
myTable2 <- function(
table,                      # matrix or data frame
xpad = 1.5,                 # cell padding in x direction
ypad = 1.5,                 # cell padding in y direction
text.bg = par("bg"),        # set table background colour
header.bg = par("bg"),        # set headers background colour
text.col = par("fg"),       # set table text colour.
header.col = par("fg"),       # set headers text colour
text.font = par("font"),    # set table font type.
header.font = par("font"),    # set headers font type
col.cex = 1.1)              # set headers text size a bit bigger than table text size
{
if (dev.cur() == 1)
stop("Cannot add table unless a graphics device is open")
# dim(n,m) means n+1 rows and m+1 columns, due to row and column names.
# text located in center of each cell
tableDim <- dim(table)
column.names <- colnames(table)
row.names <- rownames(table)
# columns have different width, then fix cex to fix table to actual size
# if we set same width for all cells, then set fontsise so all texts adjust to
# available space.
xpad <- xpad*max(strwidth(c(letters, LETTERS), units = 'fig', cex = 1))
ypad <- ypad*max(strheight(c(letters, LETTERS), units = 'fig', cex = 1))
# column names widths
colname.width <- rep(0, tableDim[2])
for (column in 1:tableDim[2]) {
colname.width[column] <- strwidth(column.names[column],
units = 'fig',
cex = col.cex) +  2*xpad
}
# actual table leads to another width value.
tableWidth <- numeric(length = tableDim[2])
for (column in 1:tableDim[2]) {
tableWidth[column] <- max(strwidth(table[, column],
units = 'fig',
cex = 1)  ) + 2*xpad
}
bothWidths <- cbind(tableWidth, colname.width)
allWidths <- apply(bothWidths, 1, max)
recRight <- Reduce('+', allWidths, accumulate = TRUE)
recLeft <- c(0, recRight[1:(length(recRight)-1)])
headerHeight <- max(strheight(column.names, units = 'fig', cex = 1)) + 2*ypad
rowHeight <- numeric(length = tableDim[1])
for(i in 1:(tableDim[1])) {
rowHeight[i] <- max(strheight(table[i, ],
units = 'fig',
cex = 1)) + 2*ypad
}
allHeights <- c(headerHeight, rowHeight)
totalHeight <- sum(allHeights)
recBottoms <- Reduce('+', allHeights, accumulate = T)
recTops <- c(0, recBottoms[1:(length(recBottoms)-1)])
xLength <- recRight[length(recRight)]
yLength<- recBottoms[length(recBottoms)]
# print(paste("xLength: ", xLength))
# print(paste("yLength: ", yLength))
if(xLength >= yLength) {
xScale <- 1/xLength
yScale <- xScale
} else {
xScale <- 1/xLength
yScale <- 1/yLength
}
# print(paste("xScale: ", xScale))
# print(paste("yScale: ", yScale))
# text.bg, white background by default
bgMatrix <- matrix(data = "white", nrow = tableDim[1], ncol = tableDim[2])
if (text.bg == 'banded') {
if(tableDim[1] > 1) {
evenrows <- seq(from = 2, to = tableDim[1], by = 2)
bgMatrix[evenrows,] <- "lightgrey"
}
} else {
bgMatrix[,] <- text.bg  # use [,] so assigment keeps matrix dimensions
}
# header.bg = par("bg")
if( is.character(header.bg) == T && length(header.bg) == 1) {
# it is ok all values same color
saveCol <- header.bg
header.bg <- rep(saveCol, tableDim[2])
} else if (length(header.bg) == tableDim[2]) {
# ok by rows
}
# text.col
if( length(text.col) == 1) {
# it is ok all values same color
saveCol <- text.col
text.col <- matrix( saveCol, nrow = tableDim[1], ncol = tableDim[2])
} else if (length(text.col) == tableDim[1]) {
# by rows
saveCol <- text.col
text.col <- matrix(' ', nrow = tableDim[1], ncol = tableDim[2])
for (row in 1:tableDim[1]) {
text.col[row, 1:tableDim[2]] <- saveCol[row]
}
} else if  (length(text.col) == tableDim[2]) {
# by columns
saveCol <- text.col
text.col <- matrix(' ', nrow = tableDim[1], ncol = tableDim[2])
for (col in 1:tableDim[2]) {
text.col[1:tableDim[1], col] <- saveCol[col]
}
} else {
# consider all default value except inputs
}
# text.font
if( length(text.font) == 1) {
# it is ok all values same color
saveFont <- text.font
text.font <- matrix(saveFont, nrow = tableDim[1], ncol = tableDim[2])
} else if (length(text.font) == tableDim[1]) {
# by rows
saveFont <- text.font
text.font <- matrix(0, nrow = tableDim[1], ncol = tableDim[2])
for (row in 1:tableDim[1]) {
text.font[row, 1:tableDim[2]] <- saveFont[row]
}
} else if  (length(text.font) == tableDim[2]) {
# by columns
saveFont <- text.font
text.font <- matrix(0, nrow = tableDim[1], ncol = tableDim[2])
for (col in 1:tableDim[2]) {
text.font[1:tableDim[1], col] <- saveFont[col]
}
} else {
# consider all default values except inputs
}
# rescale all variables
scaledWidth <- xScale*xLength
scaledHeigth <- yScale*yLength
recTops <- recTops*yScale
recBottoms <- recBottoms*yScale
headerHeight <- headerHeight*yScale
allHeights <- allHeights*yScale
recLeft <- recLeft*xScale
recRight <- recRight*xScale
allWidths <- allWidths*xScale
ytop <- 0.5*(1 + scaledHeigth)
xleft <- 0.5*(1 - scaledWidth)
# print(paste('xleft: ', xleft))
# print(paste('ytop: ', ytop))
for (column in 1:tableDim[2]) {
rect(xleft + recLeft[column], ytop - recTops[1],
xleft + recRight[column],  ytop - recBottoms[1],
col = header.bg,
border = 'black')
text(xleft + recLeft[column]  +0.5*allWidths[column], ytop - 0.5*headerHeight,
column.names[column],
cex = xScale*col.cex,
col = header.col,
font = header.font)
}
for (row in 1:tableDim[1]) {
# actual table
for (column in 1:tableDim[2]) {
rect(xleft + recLeft[column], ytop - recTops[row+1],
xleft + recRight[column], ytop - recBottoms[row+1],
col = bgMatrix[row,column],
border = 'black')
text(xleft + recLeft[column] + 0.5 * allWidths[column],
ytop - recTops[row+1] - 0.5*allHeights[row+1] ,
table[row, column],
cex = min(xScale, yScale),
col = text.col[row,column],
font = text.font[row,column])
}
par()
}
}
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
library(shiny)
library(shinyjs)
library(shinydashboard)
library(xlsx)
library(ggplot2)
library(dplyr)
library(png)
library(grid)
library(markdown)
library(reshape2)
library(forcats)
library(GGally)
library(igraph)
?ggnet2
library(shiny)
library(shinyjs)
library(shinydashboard)
library(xlsx)
library(ggplot2)
library(dplyr)
library(png)
library(grid)
library(markdown)
library(reshape2)
library(forcats)
library(GGally)
library(igraph)
source("customFunctions.R", local = TRUE)
source("plottingFunctions.R", local = TRUE)
sessionInfo()
library(shiny)
library(shinyjs)
library(shinydashboard)
library(xlsx)
library(ggplot2)
library(dplyr)
library(png)
library(grid)
library(markdown)
library(reshape2)
library(forcats)
library(GGally)
library(igraph)
library(shiny)
library(shinyjs)
library(shinydashboard)
library(xlsx)
library(ggplot2)
library(dplyr)
library(png)
library(grid)
library(markdown)
library(reshape2)
library(forcats)
library(GGally)
source("customFunctions.R", local = TRUE)
library(igraph)
source("plottingFunctions.R", local = TRUE)
sessionInfo()
library(shiny)
runApp()
shiny::runApp()
?ggnet
library(GGally)
?ggnet
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
